# generated by datamodel-codegen:
#   filename:  schema.json
#   timestamp: 2025-09-23T02:46:18+00:00

from __future__ import annotations

from typing import Annotated, Any, Literal

from pydantic import BaseModel, Field, RootModel


class AuthenticateRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    methodId: Annotated[
        str,
        Field(
            description="The ID of the authentication method to use.\nMust be one of the methods advertised in the initialize response."
        ),
    ]


class AuthenticateResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None


class AvailableCommandInput1(BaseModel):
    hint: Annotated[
        str,
        Field(description="A hint to display when the input hasn't been provided yet"),
    ]


class AvailableCommandInput(RootModel[AvailableCommandInput1]):
    root: Annotated[
        AvailableCommandInput1,
        Field(description="The input specification for a command."),
    ]


class BlobResourceContents(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    blob: str
    mimeType: str | None = None
    uri: str


class CreateTerminalResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    terminalId: Annotated[
        str, Field(description="The unique identifier for the created terminal.")
    ]


class EnvVariable(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    name: Annotated[str, Field(description="The name of the environment variable.")]
    value: Annotated[
        str, Field(description="The value to set for the environment variable.")
    ]


class FileSystemCapability(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    readTextFile: Annotated[
        bool | None,
        Field(description="Whether the Client supports `fs/read_text_file` requests."),
    ] = False
    writeTextFile: Annotated[
        bool | None,
        Field(description="Whether the Client supports `fs/write_text_file` requests."),
    ] = False


class HttpHeader(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    name: Annotated[str, Field(description="The name of the HTTP header.")]
    value: Annotated[str, Field(description="The value to set for the HTTP header.")]


class KillTerminalCommandResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None


class McpCapabilities(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    http: Annotated[
        bool | None, Field(description="Agent supports [`McpServer::Http`].")
    ] = False
    sse: Annotated[
        bool | None, Field(description="Agent supports [`McpServer::Sse`].")
    ] = False


class McpServer1(BaseModel):
    headers: Annotated[
        list[HttpHeader],
        Field(
            description="HTTP headers to set when making requests to the MCP server."
        ),
    ]
    name: Annotated[
        str, Field(description="Human-readable name identifying this MCP server.")
    ]
    type: Literal["http"] = "http"
    url: Annotated[str, Field(description="URL to the MCP server.")]


class McpServer2(BaseModel):
    headers: Annotated[
        list[HttpHeader],
        Field(
            description="HTTP headers to set when making requests to the MCP server."
        ),
    ]
    name: Annotated[
        str, Field(description="Human-readable name identifying this MCP server.")
    ]
    type: Literal["sse"] = "sse"
    url: Annotated[str, Field(description="URL to the MCP server.")]


class McpServer3(BaseModel):
    args: Annotated[
        list[str],
        Field(description="Command-line arguments to pass to the MCP server."),
    ]
    command: Annotated[str, Field(description="Path to the MCP server executable.")]
    env: Annotated[
        list[EnvVariable],
        Field(
            description="Environment variables to set when launching the MCP server."
        ),
    ]
    name: Annotated[
        str, Field(description="Human-readable name identifying this MCP server.")
    ]


class NewSessionRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    cwd: Annotated[
        str,
        Field(
            description="The working directory for this session. Must be an absolute path."
        ),
    ]
    mcpServers: Annotated[
        list[McpServer1 | McpServer2 | McpServer3],
        Field(
            description="List of MCP (Model Context Protocol) servers the agent should connect to."
        ),
    ]


class PromptCapabilities(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    audio: Annotated[
        bool | None, Field(description="Agent supports [`ContentBlock::Audio`].")
    ] = False
    embeddedContext: Annotated[
        bool | None,
        Field(
            description="Agent supports embedded context in `session/prompt` requests.\n\nWhen enabled, the Client is allowed to include [`ContentBlock::Resource`]\nin prompt requests for pieces of context that are referenced in the message."
        ),
    ] = False
    image: Annotated[
        bool | None, Field(description="Agent supports [`ContentBlock::Image`].")
    ] = False


class ReadTextFileResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    content: str


class ReleaseTerminalResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None


class RequestPermissionOutcome1(BaseModel):
    outcome: Literal["cancelled"] = "cancelled"


class RequestPermissionOutcome2(BaseModel):
    optionId: Annotated[
        str, Field(description="The ID of the option the user selected.")
    ]
    outcome: Literal["selected"] = "selected"


class RequestPermissionResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    outcome: Annotated[
        RequestPermissionOutcome1 | RequestPermissionOutcome2,
        Field(description="The user's decision on the permission request."),
    ]


class SessionUpdate8(BaseModel):
    currentModeId: Annotated[
        str, Field(description="Unique identifier for a Session Mode.")
    ]
    sessionUpdate: Literal["current_mode_update"] = "current_mode_update"


class SetSessionModeRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    modeId: Annotated[str, Field(description="The ID of the mode to set.")]
    sessionId: Annotated[
        str, Field(description="The ID of the session to set the mode for.")
    ]


class SetSessionModeResponse(BaseModel):
    meta: Any | None = None


class TerminalExitStatus(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    exitCode: Annotated[
        int | None,
        Field(
            description="The process exit code (may be null if terminated by signal).",
            ge=0,
        ),
    ] = None
    signal: Annotated[
        str | None,
        Field(
            description="The signal that terminated the process (may be null if exited normally)."
        ),
    ] = None


class TerminalOutputRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    sessionId: Annotated[str, Field(description="The session ID for this request.")]
    terminalId: Annotated[
        str, Field(description="The ID of the terminal to get output from.")
    ]


class TerminalOutputResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    exitStatus: Annotated[
        TerminalExitStatus | None,
        Field(description="Exit status if the command has completed."),
    ] = None
    output: Annotated[str, Field(description="The terminal output captured so far.")]
    truncated: Annotated[
        bool, Field(description="Whether the output was truncated due to byte limits.")
    ]


class TextResourceContents(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    mimeType: str | None = None
    text: str
    uri: str


class ToolCallContent2(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    newText: Annotated[str, Field(description="The new content after modification.")]
    oldText: Annotated[
        str | None, Field(description="The original content (None for new files).")
    ] = None
    path: Annotated[str, Field(description="The file path being modified.")]
    type: Literal["diff"] = "diff"


class ToolCallContent3(BaseModel):
    terminalId: str
    type: Literal["terminal"] = "terminal"


class ToolCallLocation(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    line: Annotated[
        int | None, Field(description="Optional line number within the file.", ge=0)
    ] = None
    path: Annotated[str, Field(description="The file path being accessed or modified.")]


class WaitForTerminalExitRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    sessionId: Annotated[str, Field(description="The session ID for this request.")]
    terminalId: Annotated[str, Field(description="The ID of the terminal to wait for.")]


class WaitForTerminalExitResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    exitCode: Annotated[
        int | None,
        Field(
            description="The process exit code (may be null if terminated by signal).",
            ge=0,
        ),
    ] = None
    signal: Annotated[
        str | None,
        Field(
            description="The signal that terminated the process (may be null if exited normally)."
        ),
    ] = None


class WriteTextFileRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    content: Annotated[str, Field(description="The text content to write to the file.")]
    path: Annotated[str, Field(description="Absolute path to the file to write.")]
    sessionId: Annotated[str, Field(description="The session ID for this request.")]


class WriteTextFileResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None


class AgentCapabilities(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    loadSession: Annotated[
        bool | None, Field(description="Whether the agent supports `session/load`.")
    ] = False
    mcpCapabilities: Annotated[
        McpCapabilities | None,
        Field(description="MCP capabilities supported by the agent."),
    ] = {"http": False, "sse": False}
    promptCapabilities: Annotated[
        PromptCapabilities | None,
        Field(description="Prompt capabilities supported by the agent."),
    ] = {"audio": False, "embeddedContext": False, "image": False}


class Annotations(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    audience: list[Literal["assistant", "user"]] | None = None
    lastModified: str | None = None
    priority: float | None = None


class AudioContent(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    data: str
    mimeType: str


class AuthMethod(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description="Optional description providing more details about this authentication method."
        ),
    ] = None
    id: Annotated[
        str, Field(description="Unique identifier for this authentication method.")
    ]
    name: Annotated[
        str, Field(description="Human-readable name of the authentication method.")
    ]


class AvailableCommand(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    description: Annotated[
        str, Field(description="Human-readable description of what the command does.")
    ]
    input: Annotated[
        AvailableCommandInput | None,
        Field(description="Input for the command if required"),
    ] = None
    name: Annotated[
        str,
        Field(description='Command name (e.g., "create_plan", "research_codebase").'),
    ]


class CancelNotification(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    sessionId: Annotated[
        str, Field(description="The ID of the session to cancel operations for.")
    ]


class ClientCapabilities(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    fs: Annotated[
        FileSystemCapability | None,
        Field(
            description="File system capabilities supported by the client.\nDetermines which file operations the agent can request."
        ),
    ] = {"readTextFile": False, "writeTextFile": False}
    terminal: Annotated[
        bool | None,
        Field(description="Whether the Client support all `terminal/*` methods."),
    ] = False


class ContentBlock1(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    text: str
    type: Literal["text"] = "text"


class ContentBlock2(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    data: str
    mimeType: str
    type: Literal["image"] = "image"
    uri: str | None = None


class ContentBlock3(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    data: str
    mimeType: str
    type: Literal["audio"] = "audio"


class ContentBlock4(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    description: str | None = None
    mimeType: str | None = None
    name: str
    size: int | None = None
    title: str | None = None
    type: Literal["resource_link"] = "resource_link"
    uri: str


class CreateTerminalRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    args: Annotated[
        list[str] | None, Field(description="Array of command arguments.")
    ] = None
    command: Annotated[str, Field(description="The command to execute.")]
    cwd: Annotated[
        str | None,
        Field(description="Working directory for the command (absolute path)."),
    ] = None
    env: Annotated[
        list[EnvVariable] | None,
        Field(description="Environment variables for the command."),
    ] = None
    outputByteLimit: Annotated[
        int | None,
        Field(
            description="Maximum number of output bytes to retain.\n\nWhen the limit is exceeded, the Client truncates from the beginning of the output\nto stay within the limit.\n\nThe Client MUST ensure truncation happens at a character boundary to maintain valid\nstring output, even if this means the retained output is slightly less than the\nspecified limit.",
            ge=0,
        ),
    ] = None
    sessionId: Annotated[str, Field(description="The session ID for this request.")]


class ImageContent(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    data: str
    mimeType: str
    uri: str | None = None


class InitializeRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    clientCapabilities: Annotated[
        ClientCapabilities | None,
        Field(description="Capabilities supported by the client."),
    ] = {"fs": {"readTextFile": False, "writeTextFile": False}, "terminal": False}
    protocolVersion: Annotated[
        int,
        Field(
            description="The latest protocol version supported by the client.",
            ge=0,
            le=65535,
        ),
    ]


class InitializeResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    agentCapabilities: Annotated[
        AgentCapabilities | None,
        Field(description="Capabilities supported by the agent."),
    ] = {
        "loadSession": False,
        "mcpCapabilities": {"http": False, "sse": False},
        "promptCapabilities": {
            "audio": False,
            "embeddedContext": False,
            "image": False,
        },
    }
    authMethods: Annotated[
        list[AuthMethod] | None,
        Field(description="Authentication methods supported by the agent."),
    ] = []
    protocolVersion: Annotated[
        int,
        Field(
            description="The protocol version the client specified if supported by the agent,\nor the latest protocol version supported by the agent.\n\nThe client should disconnect, if it doesn't support this version.",
            ge=0,
            le=65535,
        ),
    ]


class KillTerminalCommandRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    sessionId: Annotated[str, Field(description="The session ID for this request.")]
    terminalId: Annotated[str, Field(description="The ID of the terminal to kill.")]


class LoadSessionRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    cwd: Annotated[str, Field(description="The working directory for this session.")]
    mcpServers: Annotated[
        list[McpServer1 | McpServer2 | McpServer3],
        Field(description="List of MCP servers to connect to for this session."),
    ]
    sessionId: Annotated[str, Field(description="The ID of the session to load.")]


class PermissionOption(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    kind: Annotated[
        str, Field(description="Hint about the nature of this permission option.")
    ]
    name: Annotated[
        str, Field(description="Human-readable label to display to the user.")
    ]
    optionId: Annotated[
        str, Field(description="Unique identifier for this permission option.")
    ]


class PlanEntry(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    content: Annotated[
        str,
        Field(
            description="Human-readable description of what this task aims to accomplish."
        ),
    ]
    priority: Annotated[
        str,
        Field(
            description="The relative importance of this task.\nUsed to indicate which tasks are most critical to the overall goal."
        ),
    ]
    status: Annotated[str, Field(description="Current execution status of this task.")]


class PromptResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    stopReason: Annotated[
        str, Field(description="Indicates why the agent stopped processing the turn.")
    ]


class ReadTextFileRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    limit: Annotated[
        int | None, Field(description="Maximum number of lines to read.", ge=0)
    ] = None
    line: Annotated[
        int | None,
        Field(description="Line number to start reading from (1-based).", ge=0),
    ] = None
    path: Annotated[str, Field(description="Absolute path to the file to read.")]
    sessionId: Annotated[str, Field(description="The session ID for this request.")]


class ReleaseTerminalRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    sessionId: Annotated[str, Field(description="The session ID for this request.")]
    terminalId: Annotated[str, Field(description="The ID of the terminal to release.")]


class ResourceLink(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    description: str | None = None
    mimeType: str | None = None
    name: str
    size: int | None = None
    title: str | None = None
    uri: str


class SessionMode(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    description: str | None = None
    id: Annotated[str, Field(description="Unique identifier for a Session Mode.")]
    name: str


class SessionModeState(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    availableModes: Annotated[
        list[SessionMode],
        Field(description="The set of modes that the Agent can operate in"),
    ]
    currentModeId: Annotated[
        str, Field(description="The current mode the Agent is in.")
    ]


class SessionUpdate6(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    entries: Annotated[
        list[PlanEntry],
        Field(
            description="The list of tasks to be accomplished.\n\nWhen updating a plan, the agent must send a complete list of all entries\nwith their current status. The client replaces the entire plan with each update."
        ),
    ]
    sessionUpdate: Literal["plan"] = "plan"


class SessionUpdate7(BaseModel):
    availableCommands: list[AvailableCommand]
    sessionUpdate: Literal["available_commands_update"] = "available_commands_update"


class TextContent(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    text: str


class ContentBlock5(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    resource: Annotated[
        TextResourceContents | BlobResourceContents,
        Field(description="Resource content that can be embedded in a message."),
    ]
    type: Literal["resource"] = "resource"


class EmbeddedResource(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    annotations: Annotations | None = None
    resource: Annotated[
        TextResourceContents | BlobResourceContents,
        Field(description="Resource content that can be embedded in a message."),
    ]


class LoadSessionResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    modes: Annotated[
        SessionModeState | None,
        Field(
            description="Initial mode state if supported by the Agent\n\nSee protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)"
        ),
    ] = None


class NewSessionResponse(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    modes: Annotated[
        SessionModeState | None,
        Field(
            description="Initial mode state if supported by the Agent\n\nSee protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)"
        ),
    ] = None
    sessionId: Annotated[
        str,
        Field(
            description="Unique identifier for the created session.\n\nUsed in all subsequent requests for this conversation."
        ),
    ]


class Plan(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    entries: Annotated[
        list[PlanEntry],
        Field(
            description="The list of tasks to be accomplished.\n\nWhen updating a plan, the agent must send a complete list of all entries\nwith their current status. The client replaces the entire plan with each update."
        ),
    ]


class PromptRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    prompt: Annotated[
        list[
            ContentBlock1
            | ContentBlock2
            | ContentBlock3
            | ContentBlock4
            | ContentBlock5
        ],
        Field(
            description="The blocks of content that compose the user's message.\n\nAs a baseline, the Agent MUST support [`ContentBlock::Text`] and [`ContentBlock::ResourceLink`],\nwhile other variants are optionally enabled via [`PromptCapabilities`].\n\nThe Client MUST adapt its interface according to [`PromptCapabilities`].\n\nThe client MAY include referenced pieces of context as either\n[`ContentBlock::Resource`] or [`ContentBlock::ResourceLink`].\n\nWhen available, [`ContentBlock::Resource`] is preferred\nas it avoids extra round-trips and allows the message to include\npieces of context from sources the agent may not have access to."
        ),
    ]
    sessionId: Annotated[
        str, Field(description="The ID of the session to send this user message to")
    ]


class SessionUpdate1(BaseModel):
    content: Annotated[
        ContentBlock1 | ContentBlock2 | ContentBlock3 | ContentBlock4 | ContentBlock5,
        Field(
            description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)"
        ),
    ]
    sessionUpdate: Literal["user_message_chunk"] = "user_message_chunk"


class SessionUpdate2(BaseModel):
    content: Annotated[
        ContentBlock1 | ContentBlock2 | ContentBlock3 | ContentBlock4 | ContentBlock5,
        Field(
            description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)"
        ),
    ]
    sessionUpdate: Literal["agent_message_chunk"] = "agent_message_chunk"


class SessionUpdate3(BaseModel):
    content: Annotated[
        ContentBlock1 | ContentBlock2 | ContentBlock3 | ContentBlock4 | ContentBlock5,
        Field(
            description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)"
        ),
    ]
    sessionUpdate: Literal["agent_thought_chunk"] = "agent_thought_chunk"


class ToolCallContent1(BaseModel):
    content: Annotated[
        ContentBlock1 | ContentBlock2 | ContentBlock3 | ContentBlock4 | ContentBlock5,
        Field(description="The actual content block."),
    ]
    type: Literal["content"] = "content"


class ToolCallUpdate(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    content: Annotated[
        list[ToolCallContent1 | ToolCallContent2 | ToolCallContent3] | None,
        Field(description="Replace the content collection."),
    ] = None
    kind: Annotated[str | None, Field(description="Update the tool kind.")] = None
    locations: Annotated[
        list[ToolCallLocation] | None,
        Field(description="Replace the locations collection."),
    ] = None
    rawInput: Annotated[Any | None, Field(description="Update the raw input.")] = None
    rawOutput: Annotated[Any | None, Field(description="Update the raw output.")] = None
    status: Annotated[str | None, Field(description="Update the execution status.")] = (
        None
    )
    title: Annotated[
        str | None, Field(description="Update the human-readable title.")
    ] = None
    toolCallId: Annotated[
        str, Field(description="The ID of the tool call being updated.")
    ]


class RequestPermissionRequest(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    options: Annotated[
        list[PermissionOption],
        Field(description="Available permission options for the user to choose from."),
    ]
    sessionId: Annotated[str, Field(description="The session ID for this request.")]
    toolCall: Annotated[
        ToolCallUpdate,
        Field(description="Details about the tool call requiring permission."),
    ]


class SessionUpdate4(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    content: Annotated[
        list[ToolCallContent1 | ToolCallContent2 | ToolCallContent3] | None,
        Field(description="Content produced by the tool call."),
    ] = None
    kind: Annotated[
        str | None,
        Field(
            description="The category of tool being invoked.\nHelps clients choose appropriate icons and UI treatment."
        ),
    ] = None
    locations: Annotated[
        list[ToolCallLocation] | None,
        Field(
            description='File locations affected by this tool call.\nEnables "follow-along" features in clients.'
        ),
    ] = None
    rawInput: Annotated[
        Any | None, Field(description="Raw input parameters sent to the tool.")
    ] = None
    rawOutput: Annotated[
        Any | None, Field(description="Raw output returned by the tool.")
    ] = None
    sessionUpdate: Literal["tool_call"] = "tool_call"
    status: Annotated[
        str | None, Field(description="Current execution status of the tool call.")
    ] = None
    title: Annotated[
        str,
        Field(description="Human-readable title describing what the tool is doing."),
    ]
    toolCallId: Annotated[
        str,
        Field(description="Unique identifier for this tool call within the session."),
    ]


class SessionUpdate5(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    content: Annotated[
        list[ToolCallContent1 | ToolCallContent2 | ToolCallContent3] | None,
        Field(description="Replace the content collection."),
    ] = None
    kind: Annotated[str | None, Field(description="Update the tool kind.")] = None
    locations: Annotated[
        list[ToolCallLocation] | None,
        Field(description="Replace the locations collection."),
    ] = None
    rawInput: Annotated[Any | None, Field(description="Update the raw input.")] = None
    rawOutput: Annotated[Any | None, Field(description="Update the raw output.")] = None
    sessionUpdate: Literal["tool_call_update"] = "tool_call_update"
    status: Annotated[str | None, Field(description="Update the execution status.")] = (
        None
    )
    title: Annotated[
        str | None, Field(description="Update the human-readable title.")
    ] = None
    toolCallId: Annotated[
        str, Field(description="The ID of the tool call being updated.")
    ]


class ToolCall(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    content: Annotated[
        list[ToolCallContent1 | ToolCallContent2 | ToolCallContent3] | None,
        Field(description="Content produced by the tool call."),
    ] = None
    kind: Annotated[
        str | None,
        Field(
            description="The category of tool being invoked.\nHelps clients choose appropriate icons and UI treatment."
        ),
    ] = None
    locations: Annotated[
        list[ToolCallLocation] | None,
        Field(
            description='File locations affected by this tool call.\nEnables "follow-along" features in clients.'
        ),
    ] = None
    rawInput: Annotated[
        Any | None, Field(description="Raw input parameters sent to the tool.")
    ] = None
    rawOutput: Annotated[
        Any | None, Field(description="Raw output returned by the tool.")
    ] = None
    status: Annotated[
        str | None, Field(description="Current execution status of the tool call.")
    ] = None
    title: Annotated[
        str,
        Field(description="Human-readable title describing what the tool is doing."),
    ]
    toolCallId: Annotated[
        str,
        Field(description="Unique identifier for this tool call within the session."),
    ]


class SessionNotification(BaseModel):
    field_meta: Annotated[
        Any | None,
        Field(alias="_meta", description="Extension point for implementations"),
    ] = None
    sessionId: Annotated[
        str, Field(description="The ID of the session this update pertains to.")
    ]
    update: Annotated[
        SessionUpdate1
        | SessionUpdate2
        | SessionUpdate3
        | SessionUpdate4
        | SessionUpdate5
        | SessionUpdate6
        | SessionUpdate7
        | SessionUpdate8,
        Field(description="The actual update content."),
    ]


class Model(
    RootModel[
        WriteTextFileRequest
        | ReadTextFileRequest
        | RequestPermissionRequest
        | CreateTerminalRequest
        | TerminalOutputRequest
        | ReleaseTerminalRequest
        | WaitForTerminalExitRequest
        | KillTerminalCommandRequest
        | Any
        | WriteTextFileResponse
        | ReadTextFileResponse
        | RequestPermissionResponse
        | CreateTerminalResponse
        | TerminalOutputResponse
        | ReleaseTerminalResponse
        | WaitForTerminalExitResponse
        | KillTerminalCommandResponse
        | Any
        | CancelNotification
        | Any
        | InitializeRequest
        | AuthenticateRequest
        | NewSessionRequest
        | LoadSessionRequest
        | SetSessionModeRequest
        | PromptRequest
        | Any
        | InitializeResponse
        | AuthenticateResponse
        | NewSessionResponse
        | LoadSessionResponse
        | SetSessionModeResponse
        | PromptResponse
        | Any
        | SessionNotification
        | Any
    ]
):
    root: (
        WriteTextFileRequest
        | ReadTextFileRequest
        | RequestPermissionRequest
        | CreateTerminalRequest
        | TerminalOutputRequest
        | ReleaseTerminalRequest
        | WaitForTerminalExitRequest
        | KillTerminalCommandRequest
        | Any
        | WriteTextFileResponse
        | ReadTextFileResponse
        | RequestPermissionResponse
        | CreateTerminalResponse
        | TerminalOutputResponse
        | ReleaseTerminalResponse
        | WaitForTerminalExitResponse
        | KillTerminalCommandResponse
        | Any
        | CancelNotification
        | Any
        | InitializeRequest
        | AuthenticateRequest
        | NewSessionRequest
        | LoadSessionRequest
        | SetSessionModeRequest
        | PromptRequest
        | Any
        | InitializeResponse
        | AuthenticateResponse
        | NewSessionResponse
        | LoadSessionResponse
        | SetSessionModeResponse
        | PromptResponse
        | Any
        | SessionNotification
        | Any
    )
